#!/usr/bin/env python3

import argparse
import subprocess
import re
import shutil
import numpy as np
import numpy.linalg as la
from thermo import compute_thermo

# Parameters
factor = 1.3
tol = 1e-6

vgout = None

def read_options():

    parser = argparse.ArgumentParser()
    parser.add_argument("-n","--ncores",dest="ncores",type=int, default=1, help="Number of cores for vasp run")
    parser.add_argument("-c","--mpi-command",dest="command",type=str, default="srun", help="Mpi execution command e.g. mpirun, mpiexec, srun")
    parser.add_argument("-v","--vasp",dest="vasp",type=str, default="vasp_std", help="Which vasp executable to run")
    parser.add_argument("-t","--top",dest="top",type=int, default=0, help="Number of atoms to be considered from the top of the c axis for vibrationals modes")
    parser.add_argument("-o","--only",dest="list_atoms",type=str, nargs='+', default=[], help="Specific atoms to consider fro vibrational modes")
    parser.add_argument("-b","--ibrion",dest="ibrion",type=int, default=5, help="IBRION value", choices=[5, 6])
    parser.add_argument("-T","--temperature",dest="T",type=float, default=298.15, help="Temperature of the system")
    parser.add_argument("-P","--pressure",dest="P",type=float, default=101.3, help="Pressure of the system")
    parser.add_argument("-m","--molecule",dest="mol",action="store_true", default=False, help="Use this flag if the sytem is a molecule")

    args = parser.parse_args()

    return args

def prepare_incar(ibrion):

    shutil.copyfile("INCAR", "INCAR.save")

    # Read Vasp input files
    with open("INCAR", "r") as f:
        old_incar = f.read()

    if re.search("IBRION\s*=\s*[\-0-9]+", old_incar):
        new_incar =  re.sub("(IBRION\s*=\s*)[\-0-9]+", "\g<1>%d"%ibrion, old_incar)
    else:
        new_incar = old_incar + ("\n" if old_incar[-1] != "\n" else "\n") + "IBRION = %d\n"%ibrion

    new_incar =  re.sub("NSW\s*=\s*[\-0-9]+", "", new_incar)

    new_incar =  re.sub("(ISTART\s*=\s*)[\-0-9]+", "\g<1>1", new_incar)

    new_incar =  re.sub("(ICHARG\s*=\s*)[\-0-9]+", "\g<1>0", new_incar)

    with open("INCAR", "w") as f:
        f.write(new_incar)
    
def read_poscar():
    with open("POSCAR", "r") as f:
        old_poscar = f.readlines()

    scale = float(old_poscar[1].strip())

    cell = np.empty((3,3))
    for i in range(3):
        cell[:,i] = [float(a) for a in old_poscar[i+2].split()]

    cell = cell*scale

    if re.search("^\s*(?:[0-9]+\s*)+$", old_poscar[5]):
        # Use potcar atoms
        with open("POTCAR", "r") as f:
            potcar = f.read()
        elements = np.array(re.findall("TITEL\s*=\s*\w+\s*(\w+)", potcar))
        nelem = np.cumsum([int(a) for a in old_poscar[5].split()])
        last = 5
    else:
        elements = np.array(old_poscar[5].split())
        nelem = np.cumsum([int(a) for a in old_poscar[6].split()])
        last = 6

    selective = old_poscar[last+1].strip()[0].lower()=="s"

    last += (1 if selective else 0)

    cartesian = old_poscar[last + 1].strip()[0].lower() in ["c","k"]

    atoms = []
    for i, line in enumerate(old_poscar[last+2:]):
        if re.search("^\s*(?:[\-0-9\.]+\s+){3}", line):
            content = line.split()
        else:
            break
        pos = np.array([float(a) for a in content[:3]])
        
        if cartesian:
            pos = la.inv(cell).dot(pos*scale)

        elem = elements[i<=nelem-1][0]
        
        if selective:
            sel = np.array(content[3:])
        else:
            sel = None
            
        atoms.append([elem,pos,sel])

    return cell, atoms

def write_poscar(cell,atoms):

    poscar = "This poscar was generated by VaspGibbs\n1.0\n"

    for i in range(3):
        poscar += "%f %f %f\n"%(*list(cell[:,i]),)

    elements = {}
    for elem, _, _ in atoms:
        if elem in elements:
            elements[elem] += 1
        else:
            elements[elem] = 1

    poscar += " ".join(list(elements.keys())) + "\n"

    poscar += " ".join([str(a) for a in list(elements.values())]) + "\n"

    poscar += "Selective dynamics\nDirect\n"

    for _,pos,sel in atoms:
        poscar += " ".join([str(a) for a in pos]) + " "
        poscar += " ".join(sel) + "\n"

    with open("POSCAR", "w") as f:
        f.write(poscar)

def prepare_poscar(list_atoms, top, save = True):

    if save:
        shutil.copyfile("POSCAR", "POSCAR.save")

    cell, atoms = read_poscar()

    z = []
    for i,a in enumerate(atoms):
        elem, pos, sel = a
        if (elem in list_atoms) or (str(i) in list_atoms):
            sel = np.array(["T","T","T"])
        else:
            sel = np.array(["F","F","F"])
        a[2] = sel
        z.append((pos[2]+tol)%1)

    if (list_atoms == []) and (top == 0):
        top = len(atoms)

    idx  = np.argsort(z)
    for i in range(top):
        atoms[idx[-(i+1)]][2] = np.array(["T","T","T"])
    
    write_poscar(cell,atoms)

    return cell,atoms

def run_vasp(command, ncores, vasp):
    if ncores == 1:
        subprocess.run([vasp])
    else:
        subprocess.run([command, "-n", str(ncores), vasp])

def read_outcar():
    try:
        with open("OUTCAR", "r") as f:
            outcar = f.read()
    except FileNotFoundError:
        return False, None, None

    success = re.search("General timing and accounting informations for this job", outcar) is not None

    ibrion =  int(re.findall("IBRION\s*=\s*([\-0-9]+)", outcar)[-1])

    freq = []
    if re.search("Eigenvectors and eigenvalues of the dynamical matrix", outcar):
        for i, match in enumerate(re.finditer("[0-9]+\sf(\/i)*\s*=\s*([0-9.]+)", outcar)):
            if match.group(1) is None:
                freq.append(float(match.group(2)))
            else:
                print("> **Warning**: frequency %d is imaginary (i*%s). Your structure may not be properly relaxed. Ignoring this frequency."%(i, match.group(2)), file=vgout)
    else:
        freq = None

    E_dft = float(re.findall("energy  without.*sigma\->0\)\s*=\s*([0-9\-\.]+)\s*", outcar)[0])

    return success, ibrion, np.array(freq), E_dft

def print_results(T, P, E_dft, G, H, S, E_zpe, elec, vib, rot=None, trans=None):
    print("\n# Output", file=vgout)

    print("## System properties", file=vgout)
    if rot is not None and trans is not None:
        print("*This system is a molecule*", file=vgout)
    s_char="| {:^16} | {:^18} |"
    f_char="| {:^16} | {:^ 14.7g} {:^3} |"
    print(s_char.format("Property", "Value"), file=vgout)
    print(s_char.format(":--------------:", ":----------------:"), file=vgout)
    print(f_char.format("DFT Total Energy", E_dft, "eV"), file=vgout)
    print(f_char.format("Temperature", T, "K"), file=vgout)
    print(f_char.format("Pressure", P, "KPa"), file=vgout)
    print(file=vgout)
    
    print("## Energy corrections", file=vgout)
    s_char="| {:^14} | {:^14} | {:^14} | {:^14} | {:^14} |"
    f_char="| {:^14} | {:^ 14.7g} | {:^ 14.7g} | {:^ 14.7g} | {:^ 14.7g} |"
    print(s_char.format("Type", "Z", "E (eV)", "S (eV/K)", "F (eV)"), file=vgout)
    print(s_char.format(*[":------------:"]*5), file=vgout)
    print(s_char.format("ZPE", "N/A", "{:^ 14.7g}".format(E_zpe), "N/A", "N/A"), file=vgout)
    print(f_char.format("Electronic", elec.Z, elec.E, elec.S, elec.E - T*elec.S), file=vgout)
    print(f_char.format("Vibrational", vib.Z, vib.E, vib.S, vib.E - T*vib.S), file=vgout)
    if rot is not None and trans is not None:
        print(f_char.format("Rotational", rot.Z, rot.E, rot.S, rot.E - T*rot.S), file=vgout)
        print(f_char.format("Translational", trans.Z, trans.E, trans.S, trans.E - T*trans.S), file=vgout)
    print(file=vgout)
    
    print("## Thermodynamic Quantities", file=vgout)
    
    s_char="| {:^17} | {:^19} |"
    f_char="| {:^17} | {:^ 14.7g} {:^4} |"
    print(s_char.format("Quantity", "Value"), file=vgout)
    print(s_char.format(":---------------:", ":-----------------:"), file=vgout)
    print(f_char.format("Enthalpy", H, "eV"), file=vgout)
    print(f_char.format("Entropy", S, "eV/K"), file=vgout)
    print(f_char.format("Gibbs Free Energy", G, "eV"), file=vgout)
    print(f_char.format("G - E_dft", G - E_dft, "eV"), file=vgout)
    print(f_char.format("TS", T*S, "eV"), file=vgout)


def main():

    args = read_options()

    global vgout

    vgout = open("VaspGibbs.md","w")  

    print("# VaspGibbs BETA\n", file=vgout)
    print("## Parameters:", file=vgout)
    for arg in vars(args):
        print(" * ", arg, ":", vars(args)[arg], file=vgout)
    print(file=vgout)

    shutil.copyfile("POSCAR", "POSCAR.save")

    # Read the old outcar
    success, ibrion, freq, E_dft = read_outcar()

    if ibrion in [4,5,6,7]:
        print("\n*Vibrational frequencies have been calculated, using existing files.*", file=vgout)
        cell, atoms = read_poscar()

    else:
        if not success:
            print("> **Warning**: VaspGibbs must start from a completed calculation. From your OUTCAR, it seems like the calculation did not properly finish.", file=vgout)
    
        if ibrion != "-1":
            print("> **Warning**: starting from non-static run (IBRION = %2d)", file=vgout)
            print("> VaspGibbs will copy the CONTCAR to POSCAR", file=vgout)
            shutil.copyfile("POSCAR", "POSCAR.save")
            shutil.copyfile("CONTCAR", "CONTCAR.save")
            shutil.copyfile("CONTCAR", "POSCAR")
    
        prepare_incar(args.ibrion)
    
        cell, atoms = prepare_poscar(args.list_atoms, args.top, ibrion == "-1")
    
        run_vasp(args.command, args.ncores, args.vasp)

        # Reading the new outcar
        success, ibrion, freq, E_dft = read_outcar()

    results = compute_thermo(args.T, args.P, freq, E_dft, cell, atoms, args.mol)

    print_results(args.T, args.P, E_dft, *results)

main()
